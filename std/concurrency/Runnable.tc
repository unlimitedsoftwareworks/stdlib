from std.concurrency.ProcessState import ProcessState
from std.concurrency.Promise import Promise

type ProcessError = struct {
    message: string,
    code: u32
}

type EmitResult<V> = variant {
    Accepted(res: V),
    Rejected(e: ProcessError)
}

type Runnable<U, V> = interface {
    /**
     * Returns the process ID
     */
    fn id() -> u32

    /**
     * Returns the current state of the process
     */
    fn getState() -> ProcessState

    /**
     * Sends a message to the process
     * Returns a promise that will be resolved with the result of the task
     */
    fn emit(message: U) -> Promise< EmitResult<V> >


    /**
     * Ungracefully kills the process
     * This is immediate as soon as the process finishes 
     * the current active task.
     * Promises in the Queue will fail with error Killed.
     */
    fn kill() -> void

    /**
     * Sends a termination request to the process.
     * The process will stop receiving requests and 
     * will terminate as soon as the queue is empty,
     * Promise resolves will process is terminated
     */
    fn terminate() -> Promise<void>

    /**
     * Returns the size of the queue
     */
    fn getQueueSize() -> u32
}