from std.vm_api.io import io
from std.vm_api.stdcore import CastAPI

type IndexResult = variant {
    Ok(pos: u32),
    NotFound()
}

type Serilizable<T> = interface {
    fn serialize() -> u8[]
}

/**
 * UTF8-Character
 */
type Char = class {
    let buffer: u8[]

    fn init(charData: u8[]) {
        this.buffer = charData
    }

    fn bytes() -> u8[] {
        return this.buffer
    }
}

/**
 * Abstract String interface
 */
type String = interface {
    fn cat(x: u8[]) -> String
    fn cat(x: u32) -> String
    fn cat(x: i8) -> String
    fn cat(x: f32) -> String
    fn cat(x: f64) -> String
    fn cat(x: bool) -> String
    fn cat(x: u8) -> String
    fn cat(x: u16) -> String
    fn cat(x: u64) -> String
    fn cat(x: i16) -> String
    fn cat(x: i32) -> String
    fn cat(x: i64) -> String
    fn cat(x: String) -> String
    fn length() -> u64
    fn rawLength() -> u64
    /*
    fn replace(pattern: String, replacement: String) -> String
    fn split(pattern: String) -> String[]
    fn trim() -> String
    fn trimLeft() -> String
    fn trimRight() -> String
    fn toLower() -> String
    fn toUpper() -> String
    fn startsWith(pattern: String) -> bool
    fn endsWith(pattern: String) -> bool
    fn contains(pattern: String) -> bool
    fn indexOf(pattern: String) -> u64
    fn lastIndexOf(pattern: String) -> u64
    fn subString(start: u32, end: u32) -> String
    */

    fn clone() -> String
    
    /** x[i] */
    fn __index__(idx: u64) -> Char
    /** x + y */
   // fn __add__(other: String) -> String

    fn eq(other: String) -> bool

    fn bytes() -> u8[]
    
    fn __add__(other: UTF8String) -> String
    fn __add__(other: String) -> String
    fn __add__(other: u8[]) -> String
    fn __add__(other: u32) -> String
    fn __add__(other: i8) -> String
    fn __add__(other: f32) -> String
    fn __add__(other: f64) -> String
    fn __add__(other: bool) -> String
    fn __add__(other: u8) -> String
    fn __add__(other: u16) -> String
    fn __add__(other: u64) -> String
    fn __add__(other: i16) -> String
    fn __add__(other: i32) -> String
    fn __add__(other: i64) -> String

    fn toString() -> String


    

   //fn cat<T: u64|i64|f64|string>(other: T) -> String
}

/**
 * UTF8-String
 * TODO:
 * - add allocated length and actual length
 * - call new stringAppend ... for adding numbers
 */
type UTF8String = class String {
    /**
     * UTF-8 encoded buffer
     * Raw array buffer
     */
    let buffer: u8[]

    /**
     * The raw Length of the string in terms of bytes
     * not to be confused with the array buffer length.
     */
    let rawLen: u64

    /**
     * Length of the string in terms of UTF-8 Characters
     */
    let utf8Length: u64

    /**
     * Capacity of the array buffer, should be equal to buffer.length
     */
    let rawCapacity: u64


    let charIndicies: u64[]
    let charLen: u64

    /**
     * Creates a UTF-8 String from an array buffer.
     * It is a good practice to not store references of arrays but rather
     * Make copy of them
     */
    fn init(){
        this.buffer = []
        this.charIndicies = []
        this.rawLen = 0
        this.utf8Length = 0
        this.rawCapacity = 0
        this.charLen = 0
    }
    
    fn init(copy: UTF8String) {
        this.buffer = copy.buffer
        this.charIndicies = copy.charIndicies
        this.rawLen = copy.rawLen
        this.utf8Length = copy.utf8Length
        this.rawCapacity = copy.rawCapacity
        this.charLen = copy.charLen
    }

    fn init(copy: String) {
        this.init(copy.bytes())
    }

    fn init(buffer: u8[]) {
        this.buffer = []
        this.buffer.extend(buffer.length)
        
        this.charIndicies = []
        this.charIndicies.extend(buffer.length)
        
        let i: u64 = 0
        let charCounter: u64 = 0

        while i < buffer.length {
            let byte = buffer[i]

            this.charIndicies[charCounter] = i
            charCounter += 1

            // Determine the number of bytes in this UTF-8 character
            let numBytes: u8 = 0

            if (byte & 0x80) == 0 {        // 1-byte character
                numBytes = 1
                this.buffer[i] = buffer[i]
            } else if (byte & 0xE0) == 0xC0 { // 2-byte character
                numBytes = 2
                this.buffer[i] = buffer[i]
                this.buffer[i+1] = buffer[i+1]
            } else if (byte & 0xF0) == 0xE0 { // 3-byte character
                numBytes = 3
                this.buffer[i] = buffer[i]
                this.buffer[i+1] = buffer[i+1]
                this.buffer[i+2] = buffer[i+2]
            } else if (byte & 0xF8) == 0xF0 { // 4-byte character
                numBytes = 4
                this.buffer[i] = buffer[i]
                this.buffer[i+1] = buffer[i+1]
                this.buffer[i+2] = buffer[i+2]
                this.buffer[i+3] = buffer[i+3]
            } else {
                numBytes = 1
                this.buffer[i] = buffer[i]
            }

            i += numBytes
        }

        this.utf8Length = charCounter
        this.charLen = charCounter
        this.rawCapacity = buffer.length
        this.rawLen = buffer.length
    }

    fn toString() -> String {
        return this
    }

    static fn fromBytes(buffer: u8[]) -> String {
        let str = new UTF8String(buffer)
        return str
    }

    /**
     * Returns the length of the string
     */
    fn length() -> u64 {
        return this.utf8Length
    }

    /**
     * Returns the raw length of the string
     */
    fn rawLength() -> u64 {
        return this.rawLen
    }

    fn clone() -> String {
        let str = new UTF8String(this.buffer)
        return str
    }

    fn eq(other: String) -> bool {
        if this.length() != other.length() {
            return false
        }

        let otherBuffer = other.bytes()

        for let i: u64 = 0; i < this.length(); i += 1 {
            if this.buffer[i] != otherBuffer[i] {
                return false
            }
        }

        return true
    }

    /**
     * Returns the byte array representation of the string
     */
    fn bytes() -> u8[] {
        return this.buffer
    }

    /**
     * Returns the UTF-8 character at the given index
     */
    fn __index__(idx: u64) -> Char {
        return new Char([this.buffer[idx]])
    }

    /**
     * Concatenates this string with the given string, overriding this' strings buffer.
     * returns the same reference
     */
    fn __add__(other: UTF8String) -> String {
        return this.cat(other.bytes(), other.rawLength())
    }

    fn __add__(other: u8[]) -> String {
        return this.cat(other)
    }

    fn __add__(other: u32) -> String {
        return this.cat(other)
    }

    fn __add__(other: i8) -> String {
        return this.cat(other)
    }

    fn __add__(other: f32) -> String {
        return this.cat(other)
    }

    fn __add__(other: f64) -> String {
        return this.cat(other)
    }

    fn __add__(other: bool) -> String {
        return this.cat(other)
    }

    fn __add__(other: u8) -> String {
        return this.cat(other)
    }

    fn __add__(other: u16) -> String {
        return this.cat(other)
    }

    fn __add__(other: u64) -> String {
        return this.cat(other)
    }

    fn __add__(other: i16) -> String {
        return this.cat(other)
    }

    fn __add__(other: i32) -> String {
        return this.cat(other)
    }

    fn __add__(other: i64) -> String {
        return this.cat(other)
    }

    fn __add__(other: String) -> String {
        return this.cat(other)
    }

    fn cat(buffer: String) -> String {
        return this.cat(buffer.bytes(), buffer.rawLength())
    }

    fn cat(buffer: u8[]) -> String {
        return this.cat(buffer, buffer.length)
    }

    fn cat(buffer: u8[], len: u64) -> String {
        this.buffer.extend(this.buffer.length + len)
        this.charIndicies.extend(this.charIndicies.length + len)

        let i: u64 = 0
        let charCounter: u64 = this.charLen
        let offset = this.rawLen

        while i < len {
            let byte = buffer[i]

            this.charIndicies[charCounter] = i
            charCounter += 1

            // Determine the number of bytes in this UTF-8 character
            let numBytes: u8 = 0
            if (byte & 0x80) == 0 {        // 1-byte character
                numBytes = 1
                this.buffer[offset+i] = buffer[i]
            } else if (byte & 0xE0) == 0xC0 { // 2-byte character
                numBytes = 2
                this.buffer[offset+i] = buffer[i]
                this.buffer[offset+i+1] = buffer[i+1]
            } else if (byte & 0xF0) == 0xE0 { // 3-byte character
                numBytes = 3
                this.buffer[offset+i] = buffer[i]
                this.buffer[offset+i+1] = buffer[i+1]
                this.buffer[offset+i+2] = buffer[i+2]
            } else if (byte & 0xF8) == 0xF0 { // 4-byte character
                numBytes = 4
                this.buffer[offset+i] = buffer[i]
                this.buffer[offset+i+1] = buffer[i+1]
                this.buffer[offset+i+2] = buffer[i+2]
                this.buffer[offset+i+3] = buffer[i+3]
            } else {
                numBytes = 1
                this.buffer[offset+i] = buffer[i]
            }

            i += numBytes
        }

        this.utf8Length = charCounter
        this.charLen = charCounter
        this.rawCapacity += len
        this.rawLen += len

        return this
    }

    fn cat(other: UTF8String) -> String {
        return this.cat(other.bytes())
    }

    fn cat(number: u8) -> String{
        let c = CastAPI.stringAppend_u8(this.buffer, number, this.rawLen as u32)
        this.rawLen += c

        return this
    }

    fn cat(number: u16) -> String{
        let c = CastAPI.stringAppend_u16(this.buffer, number, this.rawLen as u32)
        this.rawLen += c

        return this
    }

    fn cat(number: u32) -> String{
        let c = CastAPI.stringAppend_u32(this.buffer, number, this.rawLen as u32)
        this.rawLen += c

        return this
    }

    fn cat(number: u64) -> String{
        let c = CastAPI.stringAppend_u64(this.buffer, number, this.rawLen as u32)
        this.rawLen += c

        return this
    }

    fn cat(number: i8) -> String{
        let c = CastAPI.stringAppend_i8(this.buffer, number, this.rawLen as u32)
        this.rawLen += c

        return this
    }

    fn cat(number: i16) -> String{
        let c = CastAPI.stringAppend_i16(this.buffer, number, this.rawLen as u32)
        this.rawLen += c

        return this
    }

    fn cat(number: i32) -> String{
        let c = CastAPI.stringAppend_i32(this.buffer, number, this.rawLen as u32)
        this.rawLen += c

        return this
    }

    fn cat(number: i64) -> String{
        let c = CastAPI.stringAppend_i64(this.buffer, number, this.rawLen as u32)
        this.rawLen += c
        return this
    }

    fn cat(number: f32) -> String{
        let c = CastAPI.stringAppend_f32(this.buffer, number, this.rawLen as u32)
        this.rawLen += c

        return this
    }

    fn cat(number: f64) -> String{
        let c = CastAPI.stringAppend_f64(this.buffer, number, this.rawLen as u32)
        this.rawLen += c

        return this
    }

    fn cat(number: bool) -> String{
        let c = CastAPI.stringAppend_bool(this.buffer, number, this.rawLen as u32)
        this.rawLen += c

        return this
    }    
}
